# -*- coding: utf-8 -*-

import time
import os
from collections import defaultdict
# Напишите функцию lensort, которая принимает список строк и сортирует его в порядке возрастания их длины.
# Возвращает отсортированный таким образом список. Исходный список должен остаться неизменным.


def lensort(arr):
    newarr = sorted(arr, key=len)
    print("Sorted array: ", end="")
    print(arr)
    return newarr
# •	Kак происходит передача параметра в функцию: По ссылке? По значению? По копии ссылки?
# Если в функцию передается неизменяемый объект, то этот объект передается по копии. Это значит, что изменение этого объекта внутри функции не изменит его в вызывающем коде.
# Если в функцию передается изменяемый объект, то этот объект передается по ссылке. Изменение такого объекта внутри функции повлияет на этот объект в вызывающем коде.

# •	Разница между функцией sort и методом sorted класса list
# Основное различие между ними заключается в том, что list.sort () сортирует список на месте, изменяя его индексы и возвращая None, тогда как sorted () возвращает новый отсортированный список,
# оставляя исходный список неизменным. Другое отличие состоит в том, что sorted () принимает любые итерации, в то время как list.sort ()
# является методом класса списка и может использоваться только со списками.

# • Лямбда-выражения и как их использовать вместе с sort
# функции: “одноразовые фукцнии, которые можно объявлять без использовать слова def, прямо при вызове сортировки.
# Лямбда-функция — это функция, которая состоит только из одной строки с инструкцией return, то есть функция сразу возвращает значение по набору аргументов.
# Лямбда-функции объявляются таким образом:
# lambda список переменных-аргументов: возвращаемое значение
# Например, отсортировать список чисел по последней цифре можно при помощи следующей лямбда-функции:
# a = [3, 15, 22, 13, 12, 32, 45, 43]
# a.sort(key=lambda n: n % 10)


# Напишите функцию unique, которая удаляет дубликаты из списка и возвращает результат
def unique(ls):
    print(set(ls))
# •	Какую структуру данных реализует set и как (и почему) с его помощью можно избавиться от дубликатов?
# Скорее всего, имплементация сета - хэш-таблица, где ключ и значение совпадают, соответсвенно избавляется от дупликатов он за счет того, что у дубликатов результат хэширования один и тот же

# Напишите функцию my_enumerate, которая принимает произвольный список, и возвращает список кортежей, в каждом из которых два элемента: элемент списка и порядковый номер данного элемента


def my_enumerate(en):
    print(*zip(range(len(en)), en))
# More formally: zip() returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument iterables.


# Напишите функцию, принимающую имя файла с текстом и подсчитывающую частоту встречающихся в нём слов. Каждая линия вывода имеет формат:
# «<Слово>: <Сколько раз встречается это слово>»
def word_frequency(name):
    f = open(name)
    dicr = defaultdict(lambda :0)
    for str in f:
        for word in str.split():
            dicr[word] += 1
    print(dicr)
# Что нужно знать:
# •	Что представляет собой тип dict и как им пользоваться
# Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.
# •	Как читать файлы
# Примерно так же, как в плюсах
# •	Как разделить строку с текстом на слова
#  str.split(sep=None, maxsplit=- 1)


# 5.	Напишите декоратор, который измеряет время выполнения функции и выводит его в консоль.
# Проверьте его действие на трёх функциях, принимающих список целых чисел и возвращающих список их квадратов, но выполняющих эту задачу тремя способами:
# через цикл for, через list comprehension и с использованием встроенной функции map
# Подсказки:
# •	Чтобы узнать, сколько времени, можно использовать модуль time из стандартной библиотеки
# •	list comprehension – это конструкция типа i = [i for i in …]


# декораторы в python — это просто синтаксический сахар для конструкций вида:
# function = decorator(function)
# где function - изначальная функция
# decorator - обертка над ней
def time_decorator(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(format(end - start, '.10g'))
        return result
    return wrapper


@time_decorator
def for_list(lst):
    square_list = []
    for i in lst:
        square_list.append(i**2)
    return square_list


@time_decorator
def lc_list(lst):
    return [i**2 for i in lst]


@time_decorator
def map_list(lst):
    return list(map(lambda x: x**2, lst))


# задание 1
lensort(["python", "perl", "java", "c", "haskell", "ruby"])

# задание 2
unique([1, 2, 1, 3, 2, 2, 5])

# задание 3
my_enumerate(["a", "b", "c", "47"])

# задание 4
filename = "text.txt"
f = open(filename, "w")
f.write("a a A A A b c dddd")
f.close()
word_frequency(filename)
os.remove(filename)

# задание 5
lst1 = range(1,9999999  )
for_list(lst1)
lst2 = range(1,9999999)
lc_list(lst2)
lst3 = range(1,9999999)
map_list(lst3)

# задание 6
# в файле storage.py ;)
